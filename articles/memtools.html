<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>memtools • memtools</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="memtools">
<meta property="og:description" content="memtools">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">memtools</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/memtools.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="memtools_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>memtools</h1>
            
      
      
      <div class="hidden name"><code>memtools.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">memtools</span><span class="op">)</span></code></pre></div>
<p>R is a <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage-collected</a> language. This means in practice that the programmer does not need to manage the lifetime of objects. R automatically releases the memory used up by objects that are no longer in use at periodical intervals. In garabage collected languages, memory leaks occur when some object or entity unexpectedly contains or points to an object that is otherwise no longer in use. This is because the garbage collector only reclaims the memory of unreachable objects. Without dedicated tools, detecting the source of object leaks can be very difficult, akin to finding a needle in a haystack.</p>
<p>memtools provides tools to deal with two main tasks:</p>
<ol style="list-style-type: decimal">
<li>Detecting leaked objects by comparing snapshots of the network of objects in memory.</li>
<li>Detecting which object ultimately keep alive the leaked objects, directly or indirectly.</li>
</ol>
<p>This vignette explores two case studies to illustrate these tasks.</p>
<div id="taking-a-memory-snapshot" class="section level1">
<h1 class="hasAnchor">
<a href="#taking-a-memory-snapshot" class="anchor"></a>Taking a memory snapshot</h1>
<p><code><a href="../reference/mem_snapshot.html">mem_snapshot()</a></code> is the workhorse of memtools. It takes a root object as input, traverses all reachable R objects from that root, and records their relations in a form that can be easily inspected and summarised. The output of <code><a href="../reference/mem_snapshot.html">mem_snapshot()</a></code> is a data frame that contains the graph of reachable objects, with one row per object, and metadata for that object.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="st">"foo"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; Creating snapshot...</span>
<span class="co">#&gt; Computing dominance and retainment...</span>
<span class="co">#&gt; Creating data frame...</span>

<span class="va">s</span>
<span class="co">#&gt; # A tibble: 10 x 8</span>
<span class="co">#&gt;    id       type   node   n_parents n_children n_retained retained_size gc_depth</span>
<span class="co">#&gt;    &lt;chr&gt;    &lt;chr&gt;  &lt;list&gt;     &lt;int&gt;      &lt;int&gt;      &lt;int&gt;     &lt;bch:byt&gt;    &lt;int&gt;</span>
<span class="co">#&gt;  1 0x7fc31… list   &lt;mmtl…         0          3          9          576B        1</span>
<span class="co">#&gt;  2 0x7fc32… pairl… &lt;mmtl…         1          2          4          288B        2</span>
<span class="co">#&gt;  3 0x7fc31… symbol &lt;mmtl…         1          0          0           56B        3</span>
<span class="co">#&gt;  4 0x7fc31… chara… &lt;mmtl…         1          2          2          176B        3</span>
<span class="co">#&gt;  5 0x7fc31… char   &lt;mmtl…         1          0          0           56B        4</span>
<span class="co">#&gt;  6 0x7fc31… char   &lt;mmtl…         1          0          0           56B        4</span>
<span class="co">#&gt;  7 0x7fc32… double &lt;mmtl…         1          0          0           56B        2</span>
<span class="co">#&gt;  8 0x7fc32… list   &lt;mmtl…         1          1          2          168B        2</span>
<span class="co">#&gt;  9 0x7fc32… chara… &lt;mmtl…         1          1          1          112B        3</span>
<span class="co">#&gt; 10 0x7fc31… char   &lt;mmtl…         1          0          0           56B        4</span></code></pre></div>
<ul>
<li>
<p><code>id</code>: This is the memory address of the object that serves as a unique identifier for the object. You can also retrieve the original object by dereferencing the address with <code><a href="../reference/deref.html">deref()</a></code>:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">s</span><span class="op">$</span><span class="va">id</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>
<span class="co">#&gt; [1] "0x7fc31e1bd448"</span>

<span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">s</span><span class="op">$</span><span class="va">id</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; $x</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [[2]][[1]]</span>
<span class="co">#&gt; [1] "foo"</span></code></pre></div>
</li>
<li><p><code>type</code>: The <code><a href="https://rdrr.io/r/base/typeof.html">typeof()</a></code> the object.</p></li>
<li><p><code>node</code>: This list-column contains the nodes of the object (see below).</p></li>
<li>
<p><code>n_parents</code>, <code>n_children</code>: The parents of an object are the nodes that maintain a reference to that object. For instance a list maintains references to all its elements and a function refers to the environment it was created in, its list of arguments, and the R code it executes (respectively its <code><a href="https://rdrr.io/r/base/environment.html">environment()</a></code>, <code><a href="https://rdrr.io/r/base/formals.html">formals()</a></code>, and <code><a href="https://rdrr.io/r/base/body.html">body()</a></code>).</p>
<p>The root object doesn’t have any parents recorded in the snapshot but note that it could have parents in the real graph of R objects in memory. The choice of a relevant root is thus crucial.</p>
</li>
<li><p><code>n_retained</code>, <code>retained_size</code>: These provide the number of children that would be released if the object was reclaimed by the GC, and their total size.</p></li>
<li><p><code>gc_detph</code>: This is the number of dominators that must be collected for the object to be reclaimed (see Dominance section).</p></li>
</ul>
<div id="the-graph-of-reachable-objects" class="section level2">
<h2 class="hasAnchor">
<a href="#the-graph-of-reachable-objects" class="anchor"></a>The graph of reachable objects</h2>
<p>The memory snapshot is a flat representation of the memory graph in a rectangular data frame. You can inspect and traverse the graph using the node objects of the <code>node</code> column.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">n</span> <span class="op">&lt;-</span> <span class="va">s</span><span class="op">$</span><span class="va">node</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>

<span class="va">n</span>
<span class="co">#&gt; &lt;memtools:node&gt;</span>
<span class="co">#&gt; id: "0x7fc31e1bd448"</span>
<span class="co">#&gt; type: "list"</span>
<span class="co">#&gt; parents: list [0]</span>
<span class="co">#&gt; children: list [3]</span>
<span class="co">#&gt; dominator: &lt;NULL&gt;</span>
<span class="co">#&gt; dominated: list [3]</span>
<span class="co">#&gt; self_size: 64B</span>
<span class="co">#&gt; retained_size: 576B</span>
<span class="co">#&gt; gc_depth: 1</span></code></pre></div>
<p>A node contains a little more information than the snapshot columns:</p>
<ul>
<li><p><code>parents</code>, <code>children</code>: Lists of arrow objects for the parents and children of the node.</p></li>
<li><p><code>dominator</code>, <code>dominated</code>: The memory node of the dominator and the list of dominated nodes (see Dominance section).</p></li>
<li><p><code>self_size</code>: This is the individual size of the object. Compared to <code>retained_size</code>, it doesn’t include the size of retained nodes. Most objects have a very small size except for vectors. The size of vectors (including lists) increases with their lengths.</p></li>
</ul>
<p>The <code>parents</code> and <code>children</code> fields are lists of arrow objects:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">n</span><span class="op">$</span><span class="va">children</span>
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; &lt;memtools:arrow&gt;</span>
<span class="co">#&gt; from: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; to: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; depth: 1</span>
<span class="co">#&gt; rel: "attrib"</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; &lt;memtools:arrow&gt;</span>
<span class="co">#&gt; from: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; to: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; depth: 1</span>
<span class="co">#&gt; rel: "list_elt"</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; &lt;memtools:arrow&gt;</span>
<span class="co">#&gt; from: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; to: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; depth: 1</span>
<span class="co">#&gt; rel: "list_elt"</span>
<span class="co">#&gt; i: 1</span></code></pre></div>
<p>The <code>from</code> and <code>to</code> fields of arrows point to the parent and child respectively:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">arrow</span> <span class="op">&lt;-</span> <span class="va">n</span><span class="op">$</span><span class="va">children</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>

<span class="co"># This is `n` itself</span>
<span class="fu"><a href="https://rdrr.io/r/base/identical.html">identical</a></span><span class="op">(</span><span class="va">arrow</span><span class="op">$</span><span class="va">from</span>, <span class="va">n</span><span class="op">)</span>
<span class="co">#&gt; [1] TRUE</span>

<span class="co"># This is the first child of `n`</span>
<span class="va">arrow</span><span class="op">$</span><span class="va">to</span>
<span class="co">#&gt; &lt;memtools:node&gt;</span>
<span class="co">#&gt; id: "0x7fc324111e40"</span>
<span class="co">#&gt; type: "pairlist"</span>
<span class="co">#&gt; parents: list [1]</span>
<span class="co">#&gt; children: list [2]</span>
<span class="co">#&gt; dominator: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; dominated: list [2]</span>
<span class="co">#&gt; self_size: 56B</span>
<span class="co">#&gt; retained_size: 288B</span>
<span class="co">#&gt; gc_depth: 2</span></code></pre></div>
<p>A noteworthy part of arrow objects is the <code>rel</code> field which indicates what kind of relationship unites the two nodes:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">arrow</span><span class="op">$</span><span class="va">rel</span>
<span class="co">#&gt; [1] "attrib"</span></code></pre></div>
<p>The list is the parent of an attribute field. Why is this the case? Our list is not a classed objects and we haven’t explicitly added attributes. Let’s dereference the attribute pairlist to find out. <code><a href="../reference/deref.html">deref()</a></code> accepts addresses as inputs as well as node objects:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">arrow</span><span class="op">$</span><span class="va">to</span><span class="op">)</span>
<span class="co">#&gt; $names</span>
<span class="co">#&gt; [1] "x" ""</span></code></pre></div>
<p>Indeed the snapshoted list includes names and these are stored in attributes.</p>
<p>If you’re exploring a node with many children or parents (some nodes have 1000s of parents) it can be insightful to summarise the distribution of relationships:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://purrr.tidyverse.org">purrr</a></span><span class="op">)</span>
<span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_chr</a></span><span class="op">(</span><span class="va">n</span><span class="op">$</span><span class="va">children</span>, <span class="st">"rel"</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="op">)</span>
<span class="co">#&gt; .</span>
<span class="co">#&gt;   attrib list_elt </span>
<span class="co">#&gt;        1        2</span></code></pre></div>
<p>In general, traversing the graph of objects from node to arrow to node can be slow and cumbersome. This is why memtools provides more structured ways of exploring relationships of dependence, like taking the shortest paths between a node and its dominator.</p>
</div>
<div id="compatibility-with-igraph" class="section level2">
<h2 class="hasAnchor">
<a href="#compatibility-with-igraph" class="anchor"></a>Compatibility with igraph</h2>
<p>The memtools snapshots are compatible with the <a href="https://igraph.org/r/">igraph package</a>, an R package that wraps around the C library of the same name. This library offers a large collection of fast algorithms for exploring and summarising the structure of graphs.</p>
<p>You can retrieve the igraph structure of a snapshot using <code><a href="../reference/mem_igraph.html">mem_igraph()</a></code>. The structure is created the first time it is run and then saved inside the snapshot.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_igraph.html">mem_igraph</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span>
<span class="co">#&gt; Adding igraph structure to snapshot as `mem_igraph` attribute...</span></code></pre></div>
<p>Using igraph you can visualise very small snapshots such as <code>s</code>. The nodes are labelled according to their row positions in the snapshot:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">g</span>, layout <span class="op">=</span> <span class="fu">igraph</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/igraph/man/layout_as_tree.html">layout_as_tree</a></span><span class="op">(</span><span class="va">g</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p><img src="memtools_files/figure-html/unnamed-chunk-11-1.png" width="700"></p>
<p>Most snapshots are too large to be visualised this way. igraph is still useful with these large snapshots because many advanced algorithms have near-linear complexity. memtools provides a direct interface for the most useful of these algorithms. It includes its own graph dominance algorithm and exposes igraph’s shortest paths algorithm. We’ll cover both of these in the vignette.</p>
</div>
<div id="know-your-r-internals" class="section level2">
<h2 class="hasAnchor">
<a href="#know-your-r-internals" class="anchor"></a>Know your R internals</h2>
<p>You will need some familiarity with the way R objects are structured to make sense of the raw network of relations between objects. An important case is the structure of an environment:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">e</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/environment.html">new.env</a></span><span class="op">(</span>parent <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/environment.html">emptyenv</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>
<span class="va">e</span><span class="op">$</span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">1</span>
<span class="va">e</span><span class="op">$</span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fl">2</span>

<span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="va">e</span><span class="op">)</span>
<span class="co">#&gt; Creating snapshot...</span>
<span class="co">#&gt; Computing dominance and retainment...</span>
<span class="co">#&gt; Creating data frame...</span>

<span class="va">s</span>
<span class="co">#&gt; # A tibble: 9 x 8</span>
<span class="co">#&gt;   id       type    node   n_parents n_children n_retained retained_size gc_depth</span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;chr&gt;   &lt;list&gt;     &lt;int&gt;      &lt;int&gt;      &lt;int&gt;     &lt;bch:byt&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1 0x7fc31… enviro… &lt;mmtl…         0          2          8          728B        1</span>
<span class="co">#&gt; 2 0x7fc32… list    &lt;mmtl…         1          2          6          616B        2</span>
<span class="co">#&gt; 3 0x7fc31… pairli… &lt;mmtl…         1          2          2          168B        3</span>
<span class="co">#&gt; 4 0x7fc31… symbol  &lt;mmtl…         1          0          0           56B        4</span>
<span class="co">#&gt; 5 0x7fc32… double  &lt;mmtl…         1          0          0           56B        4</span>
<span class="co">#&gt; 6 0x7fc31… pairli… &lt;mmtl…         1          2          2          168B        3</span>
<span class="co">#&gt; 7 0x7fc31… symbol  &lt;mmtl…         1          0          0           56B        4</span>
<span class="co">#&gt; 8 0x7fc32… double  &lt;mmtl…         1          0          0           56B        4</span>
<span class="co">#&gt; 9 0x7fc31… enviro… &lt;mmtl…         1          0          0           56B        2</span></code></pre></div>
<p>This environment contains only two double values but the snapshot contains a lot of intervening nodes. These extra objects come from the internal structure of the hash tables of environments: a list contains buckets of pairlists of objects.</p>
<p>Also be aware that unlike lists, pairlists consist of multiple objects:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">pairlist</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; Creating snapshot...</span>
<span class="co">#&gt; Computing dominance and retainment...</span>
<span class="co">#&gt; Creating data frame...</span>

<span class="va">s</span>
<span class="co">#&gt; # A tibble: 6 x 8</span>
<span class="co">#&gt;   id        type   node   n_parents n_children n_retained retained_size gc_depth</span>
<span class="co">#&gt;   &lt;chr&gt;     &lt;chr&gt;  &lt;list&gt;     &lt;int&gt;      &lt;int&gt;      &lt;int&gt;     &lt;bch:byt&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1 0x7fc323… pairl… &lt;mmtl…         0          2          5          336B        1</span>
<span class="co">#&gt; 2 0x7fc324… double &lt;mmtl…         1          0          0           56B        2</span>
<span class="co">#&gt; 3 0x7fc323… pairl… &lt;mmtl…         1          2          3          224B        2</span>
<span class="co">#&gt; 4 0x7fc324… double &lt;mmtl…         1          0          0           56B        3</span>
<span class="co">#&gt; 5 0x7fc323… pairl… &lt;mmtl…         1          1          1          112B        3</span>
<span class="co">#&gt; 6 0x7fc324… double &lt;mmtl…         1          0          0           56B        4</span></code></pre></div>
<p>That’s because pairlists are structured as <a href="https://en.wikipedia.org/wiki/Linked_list"><strong>linked lists</strong></a>. This is apparent if we plot the their tree structure using igraph:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_igraph.html">mem_igraph</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span>
<span class="co">#&gt; Adding igraph structure to snapshot as `mem_igraph` attribute...</span>

<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">g</span>, layout <span class="op">=</span> <span class="fu">igraph</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/igraph/man/layout_as_tree.html">layout_as_tree</a></span><span class="op">(</span><span class="va">g</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p><img src="memtools_files/figure-html/unnamed-chunk-14-1.png" width="700"></p>
</div>
<div id="the-dominance-tree" class="section level2">
<h2 class="hasAnchor">
<a href="#the-dominance-tree" class="anchor"></a>The dominance tree</h2>
<p>The graph of objects is often too complex to work with. It typically contains hundreds of thousands of objects as soon as the global environment or a namespace (which inherits from the global environment and the search path) is included. It is cyclic because environments may point to themselves (for instance a function bound to the global environment and inheriting from it). Finding leaks and their retainers from a raw snapshot is too difficult.</p>
<p>Enters the <a href="https://en.wikipedia.org/wiki/Dominator_(graph_theory)">dominance tree</a>. This is a transformation of the graph of R objects into a totally ordered tree where parent relationships towards the root can be followed without cycles. This makes it very useful for debugging leaks. The <strong>immediate dominator</strong> of an object is the closest ancestor through which all paths from the root to the object have to go. If an object has multiple parents, all of them are children or grand-children of its dominator.</p>
<p>In practice this means that the dominator of an object is the most direct ancestor that needs to be deleted for the object to be collected by the GC as well. This does not mean that the dominator is necessarily the source of the leak. However, the source can’t be higher up than the dominator. It is an upper bound in the leak search.</p>
<p>See <code><a href="https://rdrr.io/pkg/igraph/man/dominator_tree.html">?igraph::dominator_tree</a></code> for a visual representation of the dominance transformation.</p>
</div>
</div>
<div id="comparing-snapshots-to-detect-leaked-objects" class="section level1">
<h1 class="hasAnchor">
<a href="#comparing-snapshots-to-detect-leaked-objects" class="anchor"></a>Comparing snapshots to detect leaked objects</h1>
<p>There are two steps to fixing a memory leak:</p>
<ol style="list-style-type: decimal">
<li>Detect the unused objects that unexpectedly remain in memory</li>
<li>Find the objects that are keeping references to the persisting objects</li>
</ol>
<p>Sometimes you know right away which objects are leaking and you can directly start with step 2. In other cases you only know from diagnostic tools like <code><a href="https://rdrr.io/r/base/gc.html">gc()</a></code> that some memory is not being reclaimed and you need first to find out what objects hold that memory. Step 1 consists in taking two memory snapshots before and after running a reprex that causes the leak. The snapshots are then compared to find the new objects in memory.</p>
<div id="a-tidyr-leak" class="section level2">
<h2 class="hasAnchor">
<a href="#a-tidyr-leak" class="anchor"></a>A tidyr leak</h2>
<p>We illustrate step 1 with a real memory leak that affected the tidyr package from August 2020 to March 2021 (<a href="https://github.com/tidyverse/tidyr/issues/1059" class="uri">https://github.com/tidyverse/tidyr/issues/1059</a>).</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mem_reprex</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">tidyverse</span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">memtools</span><span class="op">)</span>

  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">5</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu">mutate</span><span class="op">(</span>group <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"b"</span><span class="op">)</span>, each <span class="op">=</span> <span class="va">n</span> <span class="op">/</span> <span class="op">(</span><span class="fl">2</span> <span class="op">*</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu">nest</span><span class="op">(</span>data <span class="op">=</span> <span class="op">-</span><span class="va">group</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu">spread</span><span class="op">(</span><span class="va">group</span>, <span class="va">data</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu">gather</span><span class="op">(</span><span class="va">group</span>, <span class="va">data</span>, <span class="va">a</span>, <span class="va">b</span><span class="op">)</span>

  <span class="co"># Return `NULL` to ensure results are not retained through</span>
  <span class="co"># `.Last.value`</span>
  <span class="fu"><a href="https://rdrr.io/r/base/invisible.html">invisible</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span>
<span class="op">}</span>

<span class="fu">mem_reprex</span><span class="op">(</span><span class="fl">1e8</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/base/gc.html">gc</a></span><span class="op">(</span><span class="op">)</span>
<span class="co">#&gt;            used  (Mb) gc trigger   (Mb) limit (Mb)  max used   (Mb)</span>
<span class="co">#&gt; Ncells  1083632  57.9    2084282  111.4         NA   1232191   65.9</span>
<span class="co">#&gt; Vcells 51895613 396.0  240310392 1833.5      16384 259081311 1976.7</span></code></pre></div>
<p>As you can see, a large amount of memory is retained in the vector cells of the R heap, even after deleting the data frame of results. But what exactly is leaking?</p>
</div>
<div id="select-a-snapshot-root" class="section level2">
<h2 class="hasAnchor">
<a href="#select-a-snapshot-root" class="anchor"></a>Select a snapshot root</h2>
<p>Next, create the first memory snapshot to record the current state of objects in memory. There is a choice to make here, what object are we going to supply to <code><a href="../reference/mem_snapshot.html">mem_snapshot()</a></code>? Ideally, we would take a snapshot of the <strong>GC roots</strong>, the objects from which R’s collector starts tracing. There exists several GC roots which are not made available to the R session.</p>
<p>In practice, there is only one GC root of interest, the <strong>precious list</strong>. This is (as currently implemented) a pairlist of objects protected from garbage collection through an <code>R_PreserveObject()</code> API call. Preserved objects remain in the precious list until a corresponding <code>R_ReleaseObject()</code> call. Most permanent R objects, such as the namespace registry or the global environment, are protected by the precious list. It is ultimately the most complete starting point to take a memory snapshot from.</p>
<p>However, the precious list is cumbersome to work with:</p>
<ul>
<li><p>It is internal and private. Retrieving the precious list requires some work.</p></li>
<li><p>It is rather unstructured. This is a plain linked list where parent relationships are not meaningful and only the result of the timing of preserve calls.</p></li>
<li><p>It contains large and complex objects, such as the global cache for visited bindings of the global environment and the search path.</p></li>
</ul>
<p>Since most leaks are caused by a reference that lives inside a namespace, it is often more practical to start from the namespace registry. This registry is an environment that contains all the namespaces loaded in the R session. memtools exposes it as a list to avoid encumbering the snapshots with the internal environment structures:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span>
  <span class="fu">memtools</span><span class="fu">::</span><span class="fu"><a href="../reference/roots.html">root_ns_registry</a></span><span class="op">(</span><span class="op">)</span>
<span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; List of 6</span>
<span class="co">#&gt;  $ igraph    :&lt;environment: namespace:igraph&gt; </span>
<span class="co">#&gt;  $ rstudioapi:&lt;environment: namespace:rstudioapi&gt; </span>
<span class="co">#&gt;  $ knitr     :&lt;environment: namespace:knitr&gt; </span>
<span class="co">#&gt;  $ magrittr  :&lt;environment: namespace:magrittr&gt; </span>
<span class="co">#&gt;  $ grDevices :&lt;environment: namespace:grDevices&gt; </span>
<span class="co">#&gt;  $ R6        :&lt;environment: namespace:R6&gt;</span></code></pre></div>
<p>The namespace registry strikes a good balance between exhaustivity and convenience. It is a good choice of snapshot root to start an investigation.</p>
</div>
<div id="compare-before-and-after-snapshots" class="section level2">
<h2 class="hasAnchor">
<a href="#compare-before-and-after-snapshots" class="anchor"></a>Compare before and after snapshots</h2>
<p>The first thing to do on a fresh session is to create a <strong>dry-run</strong> of the reprex. This dry-run will load any required namespace and possibly allocate global variables that some packages cache in memory the first time they need them. Initialising as much code as possible before taking the first snapshot is going to reduce the amount of noise when we’ll compare it with the second snapshot.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">mem_reprex</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></code></pre></div>
<p>Now that we have performed a dry-run of our reprex, let’s record the “before” snapshot, using the namespace registry as a starting point:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">root</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/roots.html">root_ns_registry</a></span><span class="op">(</span><span class="op">)</span>
<span class="va">before</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="va">root</span><span class="op">)</span>
<span class="co">#&gt; Creating snapshot...</span>
<span class="co">#&gt; Recorded 100000 nodes</span>
<span class="co">#&gt; Recorded 200000 nodes</span>
<span class="co">#&gt; Recorded 300000 nodes</span>
<span class="co">#&gt; Recorded 400000 nodes</span>
<span class="co">#&gt; Computing dominance and retainment...</span>
<span class="co">#&gt; Creating data frame...</span></code></pre></div>
<p>Next, run the R expression that is leaking memory:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">mem_reprex</span><span class="op">(</span><span class="fl">1e8</span><span class="op">)</span></code></pre></div>
<p>And finally, the “after” snapshot:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">after</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="va">root</span><span class="op">)</span>
<span class="co">#&gt; Creating snapshot...</span>
<span class="co">#&gt; Recorded 100000 nodes</span>
<span class="co">#&gt; Recorded 200000 nodes</span>
<span class="co">#&gt; Recorded 300000 nodes</span>
<span class="co">#&gt; Recorded 400000 nodes</span>
<span class="co">#&gt; Computing dominance and retainment...</span>
<span class="co">#&gt; Creating data frame...</span></code></pre></div>
<p>Two things to note:</p>
<ul>
<li><p>Snapshot objects are identified by their address in memory. To make it safe to compare different snapshots taken at different times, the snapshot data frame keeps all the recorded objects alive. There is no risk of R reusing an old memory address with a newly allocated object. There is a strict correspondence between elements with the same <code>id</code> as long as you keep the corresponding snapshot data frames alive.</p></li>
<li><p>The <code>after</code> snapshot does not contain any of the memory allocated as part of the <code>before</code> snapshot. That’s because <code><a href="../reference/mem_snapshot.html">mem_snapshot()</a></code> skips the bindings of the global environment by default. Since they contain the objects created in the debugging session, recording them would be inefficient (snapshot data frames are very heavy) and confusing.</p></li>
</ul>
<p>We can now find the nodes that appear in <code>after</code> but not in <code>before</code> with <code><a href="../reference/mem_diff.html">mem_diff()</a></code> (internally, this helper simply compares the <code>id</code> columns).</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">new</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_diff.html">mem_diff</a></span><span class="op">(</span><span class="va">before</span>, <span class="va">after</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">new</span><span class="op">)</span>
<span class="co">#&gt; [1] 40</span>

<span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">new</span><span class="op">$</span><span class="va">retained_size</span><span class="op">)</span>
<span class="co">#&gt;  [1]  56B  56B  56B  56B  56B  56B  56B  56B  56B  56B  56B  56B  56B</span>
<span class="co">#&gt; [14]  56B  56B  56B  56B  56B  56B  56B  56B 112B 112B 112B 112B 112B</span>
<span class="co">#&gt; [27] 168B 168B 168B 168B 168B 224B 224B 224B 280B 280B 280B 336B 336B</span>
<span class="co">#&gt; [40] 448B</span></code></pre></div>
<p>There is only 40 new objects remaining in memory. They are all small and do not explain the memory leak.</p>
</div>
<div id="snapshotting-the-precious-list" class="section level2">
<h2 class="hasAnchor">
<a href="#snapshotting-the-precious-list" class="anchor"></a>Snapshotting the precious list</h2>
<p>If the leaked objects can’t be found via the namespace registry, there is a good chance that they are leaking via the precious list. We need to change our starting point.</p>
<p>The workflow is slightly different with the precious list:</p>
<ol style="list-style-type: decimal">
<li><p>It is a private internal object so we will need to find its memory address with a debugger like <code>gdb</code> or <code>lldb</code>.</p></li>
<li><p>The objects defined in the global environment, which are normally skipped by <code><a href="../reference/mem_snapshot.html">mem_snapshot()</a></code>, will this time find their way into snapshots. They are reachable through the global binding cache that is preserved in the precious list. We will need to <strong>stash</strong> our memory snapshots to prevent them from being recorded by ulterior snapshots.</p></li>
</ol>
<p>Let’s create a memtools stash to store our debugging objects:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">stash</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_stash.html">mem_stash</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p>See <code><a href="../reference/roots.html">?roots</a></code> for how to retrieve the address of the precious list with a process debugger. Once you have the address, you can dereference it with <code>addr_deref()</code>.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">stash</span><span class="op">$</span><span class="va">root</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="st">"0x0000000105c06268"</span><span class="op">)</span></code></pre></div>
<p>Follow the steps again in a new R session, this time storing the snapshots in the stash:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Dry run</span>
<span class="fu">mem_reprex</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>

<span class="co"># First snapshot</span>
<span class="va">stash</span><span class="op">$</span><span class="va">before</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="va">stash</span><span class="op">$</span><span class="va">root</span><span class="op">)</span>

<span class="co"># Leak run</span>
<span class="fu">mem_reprex</span><span class="op">(</span><span class="fl">1e8</span><span class="op">)</span>

<span class="co"># Second snapshot</span>
<span class="va">stash</span><span class="op">$</span><span class="va">after</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="va">stash</span><span class="op">$</span><span class="va">root</span><span class="op">)</span></code></pre></div>
<p>Finally, compare the snapshots. Here are the leaking objects!</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>new &lt;-<span class="st"> </span><span class="kw">mem_diff</span>(stash<span class="op">$</span><span class="er">$</span>before, stash<span class="op">$</span><span class="er">$</span>after)</span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="kw">sort</span>(new<span class="op">$</span>retained_size)</span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="co">#&gt;  [1]  56B      56B      56B      56B      56B      56B      56B</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co">#&gt;  [8]  56B      56B      56B      56B      56B      56B      56B</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="co">#&gt; [15]  56B      56B      56B      56B      56B      56B      56B</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="co">#&gt; [22]  56B      56B      64B      64B      80B     112B     112B</span></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="co">#&gt; [29] 112B     112B     112B     112B     112B     112B     112B</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="co">#&gt; [36] 112B     112B     120B     120B     168B     168B     168B</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="co">#&gt; [43] 168B     168B     168B     176B     176B     224B     224B</span></span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="co">#&gt; [50] 224B     248B     248B     248B     280B     304B     304B</span></span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="co">#&gt; [57] 304B     360B     376B     416B     528B     560B     680B</span></span>
<span id="cb25-13"><a href="#cb25-13"></a><span class="co">#&gt; [64] 696B     736B     856B     904B     984B       1.02KB   1.23KB</span></span>
<span id="cb25-14"><a href="#cb25-14"></a><span class="co">#&gt; [71]  76.29MB  76.29MB  76.29MB  76.29MB  76.29MB 381.47MB 381.47MB</span></span>
<span id="cb25-15"><a href="#cb25-15"></a><span class="co">#&gt; [78] 381.47MB</span></span></code></pre></div>
<p>Once you’ve identified the leaking nodes, make sure they are indeed leaking through the precious list. If that is the case (and it was here), it usually means that something was preserved through <code>R_PreserveObject()</code> but not released. The snapshot can’t help you anymore. The best way forward is to examine the leaked objects to try and find clues about what they are. Use <code><a href="../reference/deref.html">deref()</a></code> to retrieve the R object of a node.</p>
<p>In our case, the leaked objects were held in a strange circular pairlist. We eventually figured out that this was the precious list of the <a href="https://cpp11.r-lib.org/">cpp11 package</a>. It was recognisable from its structure because it is a doubly linked list whose first element points to itself (see <code><a href="../reference/roots.html">?root_cpp11</a></code>). This leak was fixed a long time ago but the macOS CRAN binaries of tidyr had never been rebuilt. We sent a new version to CRAN to trigger a rebuild and fix the leak.</p>
</div>
</div>
<div id="identifying-the-source-of-a-leak" class="section level1">
<h1 class="hasAnchor">
<a href="#identifying-the-source-of-a-leak" class="anchor"></a>Identifying the source of a leak</h1>
<p>If an object is leaking through the precious list memtools cannot help finding the source. However in many cases leaks occur through unexpected references of live objects. In that case we can find the source of the leak using two graph algorithms: dominance and shortest paths.</p>
<p>In the second case study we’ll explore why namespaces <a href="https://github.com/r-lib/pkgload/pull/133">unregistered by pkgload</a> fail to be collected by R. It was not surprising that old namespaces would be retained after a <code>load_all()</code>, but we wanted to understand why that was the case.</p>
<p>In this example we know ahead of time what is the object being leaked and we don’t need to compare snapshots. Instead, we’ll take its adress with <code><a href="https://rlang.r-lib.org/reference/sexp_address.html">sexp_address()</a></code>.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">memtools</span><span class="op">)</span>

<span class="co"># Load rlang a first time. This creates a fake namespace that is</span>
<span class="co"># leaked on reloads.</span>
<span class="fu">pkgload</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/pkgload/man/load_all.html">load_all</a></span><span class="op">(</span><span class="st">"rlang"</span><span class="op">)</span>

<span class="co"># Take the address of the fake namespace</span>
<span class="va">ns_id</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/sexp_address.html">sexp_address</a></span><span class="op">(</span><span class="fu">rlang</span><span class="fu">::</span><span class="fu"><a href="https://rlang.r-lib.org/reference/ns_env.html">ns_env</a></span><span class="op">(</span><span class="st">"rlang"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>Let’s reload rlang and take a memory snapshot of the namespace registry:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Reload rlang and trigger GC</span>
<span class="fu">pkgload</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/pkgload/man/load_all.html">load_all</a></span><span class="op">(</span><span class="st">"rlang"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/invisible.html">invisible</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/gc.html">gc</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>

<span class="co"># The previous rlang namespace could now ideally be reclaimed.</span>
<span class="co"># However it is still there (R would crash or show a different object if it had been collected).</span>
<span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">ns_id</span><span class="op">)</span>
<span class="co">#&gt; &lt;environment: namespace:rlang&gt;</span>

<span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_snapshot.html">mem_snapshot</a></span><span class="op">(</span><span class="fu"><a href="../reference/roots.html">root_ns_registry</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; Creating snapshot...</span>
<span class="co">#&gt; Recorded 100000 nodes</span>
<span class="co">#&gt; Recorded 200000 nodes</span>
<span class="co">#&gt; Recorded 300000 nodes</span>
<span class="co">#&gt; Recorded 400000 nodes</span>
<span class="co">#&gt; Computing dominance and retainment...</span>
<span class="co">#&gt; Creating data frame...</span></code></pre></div>
<p>There are two main steps to figuring out how a node is leaking:</p>
<ol style="list-style-type: decimal">
<li>Find the dominator</li>
<li>Find the shortest paths between the dominator and the node</li>
</ol>
<div id="the-dominator-of-a-leaked-node" class="section level2">
<h2 class="hasAnchor">
<a href="#the-dominator-of-a-leaked-node" class="anchor"></a>The dominator of a leaked node</h2>
<p>As explained in the Dominance section, each object has a unique dominator which is the closest parent which is guaranteed to allow the object to be reclaimed by the GC if that parent was itself collected. All the paths from the root to the object must go through the dominator. This does not mean that the dominator will give us the full information about the source of the leak, but it’s the point from which you should start investigating.</p>
<p>Retrieve the dominator from the node object of the leaking rlang namespace:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Find the row position of the namespace in the snapshot</span>
<span class="op">(</span><span class="va">ns_i</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">s</span><span class="op">$</span><span class="va">id</span> <span class="op">==</span> <span class="va">ns_id</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 122617</span>

<span class="co"># Retrieve the node and its dominator</span>
<span class="op">(</span><span class="va">node</span> <span class="op">&lt;-</span> <span class="va">s</span><span class="op">$</span><span class="va">node</span><span class="op">[[</span><span class="va">ns_i</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; &lt;memtools:node&gt;</span>
<span class="co">#&gt; id: "0x7fb4cc921040"</span>
<span class="co">#&gt; type: "environment"</span>
<span class="co">#&gt; parents: list [972]</span>
<span class="co">#&gt; children: list [2]</span>
<span class="co">#&gt; dominator: &lt;mmtls_nd&gt;</span>
<span class="co">#&gt; dominated: list [2]</span>
<span class="co">#&gt; self_size: 56B</span>
<span class="co">#&gt; retained_size: 8.39MB</span>
<span class="co">#&gt; gc_depth: 2</span>

<span class="op">(</span><span class="va">dom</span> <span class="op">&lt;-</span> <span class="va">node</span><span class="op">$</span><span class="va">dominator</span><span class="op">)</span>
<span class="co">#&gt; &lt;memtools:node&gt;</span>
<span class="co">#&gt; id: "0x7fb4cc088730"</span>
<span class="co">#&gt; type: "list"</span>
<span class="co">#&gt; parents: list [0]</span>
<span class="co">#&gt; children: list [39]</span>
<span class="co">#&gt; dominator: &lt;NULL&gt;</span>
<span class="co">#&gt; dominated: list [30,080]</span>
<span class="co">#&gt; self_size: 352B</span>
<span class="co">#&gt; retained_size: 33.7MB</span>
<span class="co">#&gt; gc_depth: 1</span></code></pre></div>
<p>You can tell that the dominator is the root node because its own dominator is <code>NULL</code>. Only the root node does not have any dominator. We can make sure by dereferencing it:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">dom</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; List of 6</span>
<span class="co">#&gt;  $ rstudioapi:&lt;environment: namespace:rstudioapi&gt;</span>
<span class="co">#&gt;  $ magrittr  :&lt;environment: namespace:magrittr&gt;</span>
<span class="co">#&gt;  $ grDevices :&lt;environment: namespace:grDevices&gt;</span>
<span class="co">#&gt;  $ pkgload   :&lt;environment: namespace:pkgload&gt;</span>
<span class="co">#&gt;  $ debugme   :&lt;environment: namespace:debugme&gt;</span>
<span class="co">#&gt;  $ R6        :&lt;environment: namespace:R6&gt;</span></code></pre></div>
<p>In this case, we didn’t make any progress by taking the dominator. Our starting point is the root node. What this means in practice is that the rlang namespace is leaking through multiple paths, in this case multiple namespaces registered in the R session.</p>
</div>
</div>
<div id="inspecting-shortest-paths" class="section level1">
<h1 class="hasAnchor">
<a href="#inspecting-shortest-paths" class="anchor"></a>Inspecting shortest paths</h1>
<p>We now have two endpoints: our leaked namespace and its dominator, the namespace registry. We are ready to examine the <strong>shortest paths</strong> between these two objects.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">paths</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/mem_paths_shortest.html">mem_paths_shortest</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">node</span>, from <span class="op">=</span> <span class="va">dom</span><span class="op">)</span>
<span class="co">#&gt; Adding igraph structure to snapshot as `mem_igraph` attribute...</span>

<span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">paths</span><span class="op">)</span>
<span class="co">#&gt; [1] 8</span></code></pre></div>
<p>There are at least 8 paths through which the rlang namespace is retained. There could be additional, longer paths as well. Let’s examine one of these.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">p1</span> <span class="op">&lt;-</span> <span class="va">paths</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>

<span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">p1</span><span class="op">)</span>
<span class="co">#&gt; [1] 8</span>

<span class="co"># This list contains all the nodes of one of the first shortest path between the root ...</span>
<span class="va">p1</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>

<span class="co"># ... and the leaked object</span>
<span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">8</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></code></pre></div>
<p>As a first approach let’s examine the types of each node on the path:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://purrr.tidyverse.org">purrr</a></span><span class="op">)</span>

<span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_chr</a></span><span class="op">(</span><span class="va">p1</span>, <span class="st">"type"</span><span class="op">)</span>
<span class="co">#&gt; [1] "list"        "environment" "environment" "list"</span>
<span class="co">#&gt; [5] "pairlist"    "promise"     "closure"     "environment"</span></code></pre></div>
<p>The <code>environment -&gt; list -&gt; pairlist -&gt; promise</code> part suggests that the leak occurs through a promise bound in an environment (the sequence of environment, list and pairlists is typical of an environment hashtable).</p>
<p>Dereferencing the first nodes on the path, we see that this first leak occurs through memtools’ imports environment.</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; &lt;environment: namespace:memtools&gt;</span>

<span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; &lt;environment: 0x7fa8f19487b0&gt;</span>
<span class="co">#&gt; attr(,"name")</span>
<span class="co">#&gt; [1] "imports:memtools"</span></code></pre></div>
<p>The dependencies of a package are loaded lazily via the promise mechanism. This is a common cause of promise objects which are otherwise normally created inside execution environments of functions. You can recognise a lazyload promise from the call to <code><a href="https://rdrr.io/r/base/base-internal.html">lazyLoadDBfetch()</a></code>:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">rlang</span><span class="fu">:::</span><span class="fu">promise_expr</span><span class="op">(</span><span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; lazyLoadDBfetch(c(678142L, 422L), datafile, compressed, envhook)</span></code></pre></div>
<p>It is now clear what is happening. <code>memtools</code> was loaded after the leaked namespace was created and imported objects from that namespace via an <code>import()</code> directive. This is one of them:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">7</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; function(key, value = NULL, finalizer = NULL, on_quit = FALSE) {</span>
<span class="co">#&gt;   .Call(rlang_new_weakref, key, value, finalizer, on_quit)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;bytecode: 0x7f93a63a2068&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:rlang&gt;</span></code></pre></div>
<p>In this case this leak is not a bug but the expected behaviour. If objects were imported from our namespace between the time it was loaded and unregistered, it should continue keep working. Maybe there are other paths that are more problematic?</p>
<div id="lazily-registered-s3-methods" class="section level2">
<h2 class="hasAnchor">
<a href="#lazily-registered-s3-methods" class="anchor"></a>Lazily registered S3 methods</h2>
<p>We fixed the leaks, recorded a new snapshot, took new shortest paths, and found a similar structure. The leak occurs through the pillar namespace:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">p1</span> <span class="op">&lt;-</span> <span class="va">paths</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>

<span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_chr</a></span><span class="op">(</span><span class="va">p1</span>, <span class="st">"type"</span><span class="op">)</span>
<span class="co">#&gt;  [1] "list"        "environment" "list"        "pairlist"</span>
<span class="co">#&gt;  [5] "environment" "list"        "pairlist"    "list"</span>
<span class="co">#&gt;  [9] "closure"     "environment"</span>

<span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; &lt;environment: namespace:pillar&gt;</span>

<span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">9</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="co">#&gt; function(x) {</span>
<span class="co">#&gt;   "quos"</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:rlang&gt;</span></code></pre></div>
<p>Looking at the TAG fields of the hash table buckets, we see that this time the function inheriting from the rlang namespace leaked through the S3 registration table:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">rlang</span><span class="fu">::</span><span class="fu"><a href="https://rlang.r-lib.org/reference/new_node.html">node_tag</a></span><span class="op">(</span><span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">4</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; .__NAMESPACE__.</span>

<span class="fu">rlang</span><span class="fu">::</span><span class="fu"><a href="https://rlang.r-lib.org/reference/new_node.html">node_tag</a></span><span class="op">(</span><span class="fu"><a href="../reference/deref.html">deref</a></span><span class="op">(</span><span class="va">p1</span><span class="op">[[</span><span class="fl">7</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; S3methods</span></code></pre></div>
<p>pkgload normally unregisters the S3 methods that are documented in the NAMESPACE file. However, this misses all the methods that are lazily registered. Here are the <a href="https://github.com/r-lib/rlang/blob/e0a0761df78b327e5807875238f5ff73d8de4e10/R/rlang.R#L34-L35">faulty lines</a>.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by First Last.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
